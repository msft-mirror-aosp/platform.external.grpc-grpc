%YAML 1.2
--- |
  # THIS FILE IS FOR USE BY THE ANDROID EMULATOR CMAKE BUILD
  # ========================================================
  # This currently builds C and C++ code.
  # This file has been automatically generated from a template file.
  # Please look at the templates directory instead.
  # This file can be regenerated from the template by running
  # tools/buildgen/generate_projects.sh
  #
  # Copyright 2015 gRPC authors.
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #     http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.

  <%
  import re

  proto_re = re.compile('(.*)\\.proto')
  lib_map = {lib.name: lib for lib in libs}

  def proto_replace_ext(filename, ext):
      m = proto_re.match(filename)
      if not m:
        return filename
      return '${_gRPC_PROTO_GENS_DIR}/' + m.group(1) + ext

  def is_absl_lib(lib_name):
      return lib_name.startswith("absl/");

  def get_absl_dep(lib_name):
      return lib_map[lib_name].cmake_target

  def lib_and_transitive_deps(lib):
    return list(sorted(set({lib} | set(lib_map[lib].transitive_deps))))

  def list_abseil_pkg_targets(lib):
    # This returns a list of abseil pkg targets which the given lib and
    # its non-abseil transitive dependencies depend on.
    # As a result, internal abseil libraries are excluded from the result.
    absl_specs = set()
    for lib_name in lib_and_transitive_deps(lib):
      if is_absl_lib(lib_name): continue
      for dep in lib_map[lib_name].deps:
        if is_absl_lib(dep):
          absl_specs.add(get_absl_dep(dep).replace("::", "_"))
    return list(sorted(absl_specs))

  def is_shared_only_lib(lib_name):
    """Returns True if only shared library should be generated."""
    # grpc_csharp_ext is loaded by C# runtime and it
    # only makes sense as a shared lib.
    return lib_name in ['grpc_csharp_ext']

  def get_deps(target_dict):
    deps = []
    if target_dict.get('baselib', False) or target_dict['name'] == 'address_sorting':
      deps.append("${_gRPC_BASELIB_LIBRARIES}")
    if target_dict.get('build', None) in ['protoc']:
      deps.append("libprotoc")
    if target_dict.language == 'c++':
      deps.append("libprotobuf")
    if target_dict['name'] in ['grpc', 'grpc_cronet', 'grpc_unsecure', 'grpc_authorization_provider']:
      deps.append("zlib")
      deps.append("cares")
      deps.append("address_sorting")
      deps.append("${_gRPC_RE2_LIBRARIES}")
      deps.append("upb")
    deps.append("${_gRPC_ALLTARGETS_LIBRARIES}")
    for d in target_dict.get('deps', []):
      if d == 'benchmark':
        deps.append("${_gRPC_BENCHMARK_LIBRARIES}")
      elif d == 'libssl':
        deps.append("ssl")
        deps.append("crypto")
      elif is_absl_lib(d):
        deps.append(get_absl_dep(d))
      else:
        deps.append(d)
    return deps

  def get_platforms_condition_begin(platforms):
    if all(platform in platforms for platform in ['linux', 'mac', 'posix', 'windows']):
      return ''
    cond = ' OR '.join(['_gRPC_PLATFORM_%s' % platform.upper() for platform in platforms])
    return 'if(%s)' % cond

  def get_platforms_condition_end(platforms):
    if not get_platforms_condition_begin(platforms):
      return ''
    return 'endif()'

  def platforms_condition_block(platforms):
    def _func(text):
      lines = text.split('\n')
      cond = get_platforms_condition_begin(platforms)
      if cond:
        # Remove empty line following <%block>
        del lines[0]

        # Indent each line after
        for i, line in enumerate(lines[:-1]):
          if line:
            lines[i] = '  ' + line

        # Add the condition block
        lines.insert(0, cond)

        # Add endif() to the last line
        lines[-1] += 'endif()'
      else:
        # Remove empty line following <%block>
        del lines[0]

        # Strip leading whitespace from first line
        lines[0] = lines[0].lstrip(' ')

        # Remove empty line before </%block>
        del lines[-1]

      return '\n'.join(lines)
    return _func
  %>
  <%
  # These files are added to a set so that they are not duplicated if multiple
  # targets use them. Generating the same file multiple times with
  # add_custom_command() is not allowed in CMake.

  protobuf_gen_files = set()
  for tgt in targets:
    for src in tgt.src:
      if proto_re.match(src):
        protobuf_gen_files.add(src)
  for lib in libs:
    for src in lib.src:
      if proto_re.match(src):
        protobuf_gen_files.add(src)
  %>

  cmake_minimum_required(VERSION 3.5.1)
  cmake_policy(SET CMP0079 NEW)


  set(PACKAGE_NAME          "grpc")
  set(PACKAGE_VERSION       "${settings.cpp_version}")
  set(gRPC_CORE_VERSION     "${settings.core_version}")
  set(gRPC_CORE_SOVERSION   "${settings.core_version.major}")
  set(gRPC_CPP_VERSION      "${settings.cpp_version}")
  set(gRPC_CPP_SOVERSION    "${settings.cpp_version.major}.${settings.cpp_version.minor}")
  set(gRPC_CSHARP_VERSION   "${settings.csharp_version}")
  set(gRPC_CSHARP_SOVERSION "${settings.csharp_version.major}.${settings.csharp_version.minor}")
  set(PACKAGE_STRING        "<%text>${PACKAGE_NAME} ${PACKAGE_VERSION}</%text>")
  set(PACKAGE_TARNAME       "<%text>${PACKAGE_NAME}-${PACKAGE_VERSION}</%text>")
  set(PACKAGE_BUGREPORT     "https://github.com/grpc/grpc/issues/")
  project(<%text>${PACKAGE_NAME}</%text> LANGUAGES C CXX)

  set(gRPC_INSTALL_BINDIR "bin" CACHE STRING "Installation directory for executables")
  set(gRPC_INSTALL_LIBDIR "lib" CACHE STRING "Installation directory for libraries")
  set(gRPC_INSTALL_INCLUDEDIR "include" CACHE STRING "Installation directory for headers")
  set(gRPC_INSTALL_CMAKEDIR "lib/cmake/<%text>${PACKAGE_NAME}</%text>" CACHE STRING "Installation directory for cmake config files")
  set(gRPC_INSTALL_SHAREDIR "share/grpc" CACHE STRING "Installation directory for root certificates")
  set(gRPC_BUILD_MSVC_MP_COUNT 0 CACHE STRING "The maximum number of processes for MSVC /MP option")

  # Options
  option(gRPC_BUILD_TESTS "Build tests" OFF)
  option(gRPC_BUILD_CODEGEN "Build codegen" ON)
  option(gRPC_BUILD_CSHARP_EXT "Build C# extensions" OFF)
  option(gRPC_BACKWARDS_COMPATIBILITY_MODE "Build libraries that are binary compatible across a larger number of OS and libc versions" OFF)

  set(gRPC_INSTALL_default OFF)
  if(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
    # Disable gRPC_INSTALL by default if building as a submodule
    set(gRPC_INSTALL_default OFF)
  endif()
  set(gRPC_INSTALL <%text>${gRPC_INSTALL_default}</%text> CACHE BOOL
      "Generate installation target")

  # We can install dependencies from submodules if we're running
  # CMake v3.13 or newer.
  if(CMAKE_VERSION VERSION_LESS 3.13)
    set(_gRPC_INSTALL_SUPPORTED_FROM_MODULE OFF)
  else()
    set(_gRPC_INSTALL_SUPPORTED_FROM_MODULE ON)
  endif()

  # Providers for third-party dependencies (gRPC_*_PROVIDER properties):
  # "module": build the dependency using sources from git submodule (under third_party)
  # "package": use cmake's find_package functionality to locate a pre-installed dependency

  set(gRPC_ZLIB_PROVIDER "module" CACHE STRING "Provider of zlib library")
  set_property(CACHE gRPC_ZLIB_PROVIDER PROPERTY STRINGS "module" "package")

  set(gRPC_CARES_PROVIDER "module" CACHE STRING "Provider of c-ares library")
  set_property(CACHE gRPC_CARES_PROVIDER PROPERTY STRINGS "module" "package")

  set(gRPC_RE2_PROVIDER "module" CACHE STRING "Provider of re2 library")
  set_property(CACHE gRPC_RE2_PROVIDER PROPERTY STRINGS "module" "package")

  set(gRPC_SSL_PROVIDER "module" CACHE STRING "Provider of ssl library")
  set_property(CACHE gRPC_SSL_PROVIDER PROPERTY STRINGS "module" "package")

  set(gRPC_PROTOBUF_PROVIDER "module" CACHE STRING "Provider of protobuf library")
  set_property(CACHE gRPC_PROTOBUF_PROVIDER PROPERTY STRINGS "module" "package")

  set(gRPC_PROTOBUF_PACKAGE_TYPE "" CACHE STRING "Algorithm for searching protobuf package")
  set_property(CACHE gRPC_PROTOBUF_PACKAGE_TYPE PROPERTY STRINGS "CONFIG" "MODULE")

  if(gRPC_BUILD_TESTS)
    set(gRPC_BENCHMARK_PROVIDER "module" CACHE STRING "Provider of benchmark library")
    set_property(CACHE gRPC_BENCHMARK_PROVIDER PROPERTY STRINGS "module" "package")
  else()
    set(gRPC_BENCHMARK_PROVIDER "none")
  endif()

  set(gRPC_ABSL_PROVIDER "module" CACHE STRING "Provider of absl library")
  set_property(CACHE gRPC_ABSL_PROVIDER PROPERTY STRINGS "module" "package")
  <%
    # Collect all abseil rules used by gpr, grpc, so on.
    used_abseil_rules = set()
    for lib in libs:
      if lib.get("baselib"):
        for dep in lib.transitive_deps:
          if is_absl_lib(dep):
            used_abseil_rules.add(lib_map[dep].cmake_target.replace("::", "_"))
  %>
  set(gRPC_ABSL_USED_TARGETS
  % for rule in sorted(used_abseil_rules):
    ${rule}
  % endfor
    absl_meta
  )

  set(gRPC_USE_PROTO_LITE OFF CACHE BOOL "Use the protobuf-lite library")

  get_filename_component(_gRPC_ROOT "<%text>${CMAKE_CURRENT_LIST_DIR}/..</%text>" ABSOLUTE)

  if(LINUX_X86_64 OR LINUX_AARCH64)
     set(_gRPC_PLATFORM_LINUX ON)
     set(_gRPC_PLATFORM_POSIX ON)
  elseif(DARWIN_X86_64 OR DARWIN_AARCH64)
     set(_gRPC_PLATFORM_MAC ON)
     set(_gRPC_PLATFORM_POSIX ON)
  else()
   set(_gRPC_PLATFORM_WINDOWS ON)
  endif()

  # Use C99 standard
  if (NOT DEFINED CMAKE_C_STANDARD)
    set(CMAKE_C_STANDARD 99)
  endif()


  set(_gRPC_PROTOBUF_LIBRARY_NAME "libprotobuf")


  <%text>include(${CMAKE_CURRENT_LIST_DIR}/../cmake/upb.cmake)</%text>
  <%text>include(${CMAKE_CURRENT_LIST_DIR}/../cmake/xxhash.cmake)</%text>
  <%text>include(${CMAKE_CURRENT_LIST_DIR}/../cmake/address_sorting.cmake)</%text>

  # Make sure we have the protoc plugin available.
  <%text>android_compile_for_host(grpc_cpp_plugin ${CMAKE_CURRENT_LIST_DIR}/plugins GRPC_CPP_PLUGIN_EXE)</%text>
  <%text>set(_gRPC_CPP_PLUGIN_EXECUTABLE ${GRPC_CPP_PLUGIN_EXE} CACHE PATH "Grpc cpp plugin" FORCE)</%text>
  <%text>set(_gRPC_PROTOBUF_PROTOC_EXECUTABLE ${PROTOBUF_PROTOC_EXECUTABLE} CACHE PATH "Protocol buffer executable" FORCE)</%text>

  if(_gRPC_PLATFORM_MAC OR _gRPC_PLATFORM_IOS)
    set(_gRPC_ALLTARGETS_LIBRARIES <%text>${CMAKE_DL_LIBS}</%text> m pthread)
  elseif(_gRPC_PLATFORM_ANDROID)
    set(_gRPC_ALLTARGETS_LIBRARIES <%text>${CMAKE_DL_LIBS}</%text> m)
  elseif(_gRPC_PLATFORM_LINUX)
    set(_gRPC_ALLTARGETS_LIBRARIES <%text>${CMAKE_DL_LIBS}</%text> rt m pthread)
  endif()

  if(WIN32)
    set(_gRPC_BASELIB_LIBRARIES ws2_32::ws2_32 crypt32::crypt32)
  endif()

  # Create directory for generated .proto files
  set(_gRPC_PROTO_GENS_DIR <%text>${CMAKE_BINARY_DIR}/gens</%text>)
  file(MAKE_DIRECTORY <%text>${_gRPC_PROTO_GENS_DIR}</%text>)
  #  protobuf_generate_grpc_cpp
  #  --------------------------
  #
  #   Add custom commands to process ``.proto`` files to C++ using protoc and
  #   GRPC plugin::
  #
  #     protobuf_generate_grpc_cpp [<ARGN>...]
  #
  #   ``SOURCE_DIR``
  #      Root directory where sources can be found, defaults to CMAKE_CURRENT_SOURCE_DIR
  #   ``OUTPUT_DIR``
  #      Directory where the generated sources will be placed, defaults to CMAKE_CURRENT_BINARY_DIR/gens
  #   ``INCLUDES``
  #       Specify the directores in which to search for imports. Directories will be searched in order.
  #   ``GENERATED``
  #      Variable that should contain the list of generated sources.
  #   ``SOURCES``
  #     ``.proto`` files
  #
  function(protobuf_generate_grpc_cpp)
    # Parse arguments
    set(options)
    set(oneValueArgs SOURCE_DIR OUTPUT_DIR GENERATED INCLUDES)
    set(multiValueArgs SOURCES)
    cmake_parse_arguments(grpc "<%text>${options}</%text>"
                               "<%text>${oneValueArgs}</%text>"
                               "<%text>${multiValueArgs}</%text>"
                               <%text>${ARGN}</%text>)

    if (NOT grpc_OUTPUT_DIR)
        set(grpc_OUTPUT_DIR <%text>${_gRPC_PROTO_GENS_DIR}</%text>)
    endif()
    if (NOT grpc_SOURCE_DIR)
        set(grpc_SOURCE_DIR <%text>${CMAKE_CURRENT_SOURCE_DIR}</%text>)
    endif()
    if(NOT grpc_SOURCES)
      message(SEND_ERROR "Error: PROTOBUF_GENERATE_GRPC_CPP() called without any proto files")
      return()
    endif()
    list(APPEND grpc_INCLUDES ".")
    list(APPEND grpc_INCLUDES "<%text>${ANDROID_QEMU2_TOP_DIR}/../protobuf/src</%text>")
    unset(GRPC_INCLUDES)
    foreach(INC <%text>${grpc_INCLUDES}</%text>)
        set(GRPC_INCLUDES <%text>${GRPC_INCLUDES} -I${INC}</%text>)
    endforeach()

    set(GRPC_PROTO_GEN "")
    set(_LOCAL_GRPC "<%text>${ANDROID_QEMU2_TOP_DIR}/../grpc/emulator</%text>")

    if(NOT Python3_EXECUTABLE)
      find_package(Python3 COMPONENTS Interpreter)
      if(NOT Python3_FOUND)
        message(FATAL_ERROR "A python interpreter is required. ")
      endif()
    endif()
    set(exe <%text>"${_LOCAL_GRPC}/compile_grpc.py"</%text>)

    foreach(FIL <%text>${grpc_SOURCES}</%text>)
      get_filename_component(ABS_FIL <%text>${FIL}</%text> ABSOLUTE)
      <%text>if(NOT EXISTS "${ABS_FIL}")</%text>
      <%text>  get_filename_component(ABS_FIL "${grpc_SOURCE_DIR}/${FIL}" ABSOLUTE)</%text>
      endif()
      get_filename_component(FIL_WE <%text>${FIL}</%text> NAME_WE)
      file(RELATIVE_PATH REL_FIL <%text>${grpc_SOURCE_DIR}</%text> <%text>${ABS_FIL}</%text>)
      get_filename_component(REL_DIR <%text>${REL_FIL}</%text> DIRECTORY)
      set(RELFIL_WE "<%text>${REL_DIR}/${FIL_WE}</%text>")

      add_custom_command(
        OUTPUT <%text>"${grpc_OUTPUT_DIR}/${RELFIL_WE}.grpc.pb.cc"</%text>
               <%text>"${grpc_OUTPUT_DIR}/${RELFIL_WE}.grpc.pb.h"</%text>
               <%text>"${grpc_OUTPUT_DIR}/${RELFIL_WE}_mock.grpc.pb.h"</%text>
               <%text>"${grpc_OUTPUT_DIR}/${RELFIL_WE}.pb.cc"</%text>
               <%text>"${grpc_OUTPUT_DIR}/${RELFIL_WE}.pb.h"</%text>
        COMMAND <%text>${Python3_EXECUTABLE} ${exe} ${_gRPC_PROTOBUF_PROTOC_EXECUTABLE}</%text>
        ARGS --grpc_out=<%text>generate_mock_code=true:${grpc_OUTPUT_DIR}</%text>
             --cpp_out=<%text>${grpc_OUTPUT_DIR}</%text>
             --plugin=protoc-gen-grpc=<%text>${_gRPC_CPP_PLUGIN_EXECUTABLE}</%text>
             <%text>${GRPC_INCLUDES}</%text>
             <%text>${REL_FIL}</%text>
        DEPENDS <%text>${ABS_FIL}</%text> <%text>${_gRPC_PROTOBUF_PROTOC_EXECUTABLE} ${_gRPC_CPP_PLUGIN_EXECUTABLE}</%text>
        WORKING_DIRECTORY <%text>${grpc_SOURCE_DIR}</%text>
        COMMENT "Running gRPC C++ protocol buffer compiler on <%text>${FIL} (using ${exe})</%text>"
        VERBATIM)

        <%text>list(APPEND GRPC_PROTO_GEN "${grpc_OUTPUT_DIR}/${RELFIL_WE}.grpc.pb.cc")</%text>
        <%text>list(APPEND GRPC_PROTO_GEN "${grpc_OUTPUT_DIR}/${RELFIL_WE}.grpc.pb.h")</%text>
        <%text>list(APPEND GRPC_PROTO_GEN "${grpc_OUTPUT_DIR}/${RELFIL_WE}_mock.grpc.pb.h")</%text>
        <%text>list(APPEND GRPC_PROTO_GEN "${grpc_OUTPUT_DIR}/${RELFIL_WE}.pb.cc")</%text>
        <%text>list(APPEND GRPC_PROTO_GEN "${grpc_OUTPUT_DIR}/${RELFIL_WE}.pb.h")</%text>
        <%text>set_source_files_properties("${grpc_OUTPUT_DIR}/${RELFIL_WE}.grpc.pb.cc" "${grpc_OUTPUT_DIR}/${RELFIL_WE}.grpc.pb.h"  "${grpc_OUTPUT_DIR}/${RELFIL_WE}_mock.grpc.pb.h" "${grpc_OUTPUT_DIR}/${RELFIL_WE}.pb.cc" "${grpc_OUTPUT_DIR}/${RELFIL_WE}.pb.h" PROPERTIES GENERATED TRUE)</%text>
    endforeach()
    if (grpc_GENERATED)
      <%text>set(${grpc_GENERATED} "${GRPC_PROTO_GEN}" PARENT_SCOPE)</%text>
    endif()
  endfunction()

  protobuf_generate_grpc_cpp(
    <%text>SOURCE_DIR ${_gRPC_ROOT}</%text>
    <%text>INCLUDES ${_gRPC_ROOT}/src//proto/grpc/reflection/v1alpha</%text>
    SOURCES src/proto/grpc/reflection/v1alpha/reflection.proto
    <%text>OUTPUT_DIR ${_gRPC_PROTO_GENS_DIR}</%text>
    GENERATED REFLECTION_GRPC_SRC)

  <%
    cmake_libs = []
    for lib in libs:
      if lib.build not in ["all", "protoc", "tool", "test", "private"] or lib.boringssl: continue
      if lib.get('build_system', []) and 'cmake' not in lib.get('build_system', []): continue
      if lib.name in ['ares', 'benchmark', 're2', 'xxhash', 'z']: continue  # we build these using CMake instead
      if is_absl_lib(lib.name): continue  # we build these using CMake instead
      cmake_libs.append(lib)
  %>
  % for lib in cmake_libs:
  %   if lib.build in ["test", "private"]:
  # Not building test ${lib.name}, ${lib.build}
  %   elif lib.name in ['grpc_csharp_ext', 'grpc_plugin_support', 'grpcpp_channelz']:
  # Not building ${lib.name}
  %   else:
  ${cc_library(lib)}
  %   endif
  % endfor

  % for tgt in targets:
  % if tgt.build in ["all", "protoc", "tool", "test", "private"] and not tgt.boringssl:
  % if tgt.build in ["test", "private"]:
  # Not building test: ${tgt.build}
  % elif tgt.build in ["protoc", "grpc_plugin_support", "grpc++_reflection"]:
  # No codegen ${tgt.name}
  % else:
  <%block filter='platforms_condition_block(tgt.platforms)'>
  ${cc_binary(tgt)}
  % if not tgt.build in ["tool"]:
  ${cc_install(tgt)}
  % endif
  </%block>
  % endif
  % endif
  % endfor

  <%def name="cc_library(lib)">
  % if any(proto_re.match(src) for src in lib.src):
  % if lib.name == 'grpcpp_channelz':
  # grpcpp_channelz doesn't build with protobuf-lite
  # See https://github.com/grpc/grpc/issues/19473
  if(gRPC_BUILD_CODEGEN AND NOT gRPC_USE_PROTO_LITE)
  % else:
  if(gRPC_BUILD_CODEGEN)
  % endif
  % endif
  android_add_library(TARGET ${lib.name}
  LICENSE Apache-2.0
  URL "https://android.googlesource.com/platform/external/grpc-grpc/+/refs/heads/emu-master-dev"
  <%text>REPO "${ANDROID_QEMU2_TOP_DIR}/../grpc"</%text>
  NOTICE "REPO/NOTICE.txt"
  ${'SHARED' if lib.get('dll', None) == 'only' else ''}
  SRC # cmake-format: sortable
  % for src in lib.src:
  % if not proto_re.match(src):
    <%text>${_gRPC_ROOT}/</%text>${src}
  % else:
    ${proto_replace_ext(src, '.pb.cc')}
    ${proto_replace_ext(src, '.grpc.pb.cc')}
    ${proto_replace_ext(src, '.pb.h')}
    ${proto_replace_ext(src, '.grpc.pb.h')}
    % if src in ["src/proto/grpc/testing/compiler_test.proto", "src/proto/grpc/testing/echo.proto"]:
    ${proto_replace_ext(src, '_mock.grpc.pb.h')}
    % endif
  % endif
  % endfor
  )



  target_include_directories(${lib.name}
    PUBLIC  <%text>${_gRPC_ROOT}/include</%text>
    PRIVATE
      <%text>${_gRPC_ROOT}</%text>
      <%text>${_gRPC_ADDRESS_SORTING_INCLUDE_DIR}</%text>
      <%text>${_gRPC_RE2_INCLUDE_DIR}</%text>
      <%text>${_gRPC_SSL_INCLUDE_DIR}</%text>
      <%text>${_gRPC_UPB_GENERATED_DIR}</%text>
      <%text>${_gRPC_UPB_GRPC_GENERATED_DIR}</%text>
      <%text>${_gRPC_UPB_INCLUDE_DIR}</%text>
      <%text>${_gRPC_XXHASH_INCLUDE_DIR}</%text>
      <%text>${_gRPC_ZLIB_INCLUDE_DIR}</%text>
  % if lib.build in ['test', 'private'] and lib.language == 'c++':
      third_party/googletest/googletest/include
      third_party/googletest/googletest
      third_party/googletest/googlemock/include
      third_party/googletest/googlemock
  % endif
  % if lib.language == 'c++':
      <%text>${_gRPC_PROTO_GENS_DIR}</%text>
  % endif
  )
  % if len(get_deps(lib)) > 0:
  target_link_libraries(${lib.name} PUBLIC
  % for dep in get_deps(lib):
    ${dep}
  % endfor
  )
  % endif
  % if lib.name in ["grpc", "grpc_cronet", "grpc_test_util", \
                    "grpc_test_util_unsecure", "grpc_unsecure", \
                    "grpc++_cronet"]:
  if(_gRPC_PLATFORM_IOS OR _gRPC_PLATFORM_MAC)
    target_link_libraries(${lib.name} PRIVATE "-framework CoreFoundation")
  endif()
  %endif

  % if any(proto_re.match(src) for src in lib.src):
  endif()
  % endif
  </%def>

  <%def name="cc_binary(tgt)">
  android_add_executable(TARGET ${tgt.name} NODISTRIBUTE
  SRC # cmake-format: sortable
  % for src in tgt.src:
  % if not proto_re.match(src):
    <%text>${_gRPC_ROOT}/</%text>${src}
  % else:
    ${proto_replace_ext(src, '.pb.cc')}
    ${proto_replace_ext(src, '.grpc.pb.cc')}
    ${proto_replace_ext(src, '.pb.h')}
    ${proto_replace_ext(src, '.grpc.pb.h')}
  % endif
  % endfor
  % if tgt.build == 'test' and tgt.language == 'c++':
    third_party/googletest/googletest/src/gtest-all.cc
    third_party/googletest/googlemock/src/gmock-all.cc
  % endif
  )

  target_include_directories(${tgt.name}
    PRIVATE
      <%text>${_gRPC_ROOT}</%text>
      <%text>${_gRPC_ROOT}</%text>/include
      <%text>${_gRPC_ADDRESS_SORTING_INCLUDE_DIR}</%text>
      <%text>${_gRPC_RE2_INCLUDE_DIR}</%text>
      <%text>${_gRPC_SSL_INCLUDE_DIR}</%text>
      <%text>${_gRPC_UPB_GENERATED_DIR}</%text>
      <%text>${_gRPC_UPB_GRPC_GENERATED_DIR}</%text>
      <%text>${_gRPC_UPB_INCLUDE_DIR}</%text>
      <%text>${_gRPC_XXHASH_INCLUDE_DIR}</%text>
      <%text>${_gRPC_ZLIB_INCLUDE_DIR}</%text>
  % if tgt.build in ['test', 'private'] and tgt.language == 'c++':
      third_party/googletest/googletest/include
      third_party/googletest/googletest
      third_party/googletest/googlemock/include
      third_party/googletest/googlemock
  % endif
  % if tgt.language == 'c++':
      <%text>${_gRPC_PROTO_GENS_DIR}</%text>
  % endif
  )

  % if len(get_deps(tgt)) > 0:
  target_link_libraries(${tgt.name} PRIVATE
  % for dep in get_deps(tgt):
    ${dep}
  % endfor
  )

  % endif
  </%def>

  <%def name="cc_install(tgt)">
  # Not installing ${tgt.name}
  </%def>
